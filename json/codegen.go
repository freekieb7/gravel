package json

import (
	"fmt"
	"reflect"
	"strings"
)

// CompileTimeEncoder generates optimized encoders at compile time
type CompileTimeEncoder struct {
	encoders map[reflect.Type]string
}

// GenerateEncoder creates an optimized encoder for a specific type
func (c *CompileTimeEncoder) GenerateEncoder(t reflect.Type) (string, error) {
	if t.Kind() != reflect.Struct {
		return "", fmt.Errorf("can only generate encoders for struct types")
	}

	var code strings.Builder

	// Generate function signature
	funcName := fmt.Sprintf("encode%s", t.Name())
	code.WriteString(fmt.Sprintf("func %s(v %s, w writer) error {\n", funcName, t.String()))

	// Generate field encoding
	code.WriteString("\tif err := w.WriteByte('{'); err != nil { return err }\n")
	code.WriteString("\tfirst := true\n")

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}

		jsonTag := field.Tag.Get("json")
		fieldName := field.Name

		if jsonTag != "" && jsonTag != "-" {
			parts := strings.Split(jsonTag, ",")
			if parts[0] != "" {
				fieldName = parts[0]
			}
		}

		// Generate field encoding logic
		code.WriteString("\tif !first {\n")
		code.WriteString("\t\tif err := w.WriteByte(','); err != nil { return err }\n")
		code.WriteString("\t}\n")
		code.WriteString("\tfirst = false\n")

		// Write field name
		code.WriteString(fmt.Sprintf("\tif err := w.WriteString(`\"%s\":`); err != nil { return err }\n", fieldName))

		// Generate type-specific encoding
		switch field.Type.Kind() {
		case reflect.String:
			code.WriteString("\tif err := w.WriteByte('\"'); err != nil { return err }\n")
			code.WriteString(fmt.Sprintf("\tif err := escapeStringFast(v.%s, w); err != nil { return err }\n", field.Name))
			code.WriteString("\tif err := w.WriteByte('\"'); err != nil { return err }\n")
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			code.WriteString(fmt.Sprintf("\t{\n\t\ti := int64(v.%s)\n", field.Name))
			code.WriteString("\t\tif i < 0 {\n")
			code.WriteString("\t\t\tif err := w.WriteByte('-'); err != nil { return err }\n")
			code.WriteString("\t\t\ti = -i\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\tif i < int64(len(smallInts)) {\n")
			code.WriteString("\t\t\tif err := w.WriteString(smallInts[i]); err != nil { return err }\n")
			code.WriteString("\t\t} else if i < 100 {\n")
			code.WriteString("\t\t\tif err := w.WriteString(twoDigits[i]); err != nil { return err }\n")
			code.WriteString("\t\t} else {\n")
			code.WriteString(fmt.Sprintf("\t\t\tif err := w.WriteString(strconv.FormatInt(int64(v.%s), 10)); err != nil { return err }\n", field.Name))
			code.WriteString("\t\t}\n\t}\n")
		case reflect.Bool:
			code.WriteString(fmt.Sprintf("\tif v.%s {\n", field.Name))
			code.WriteString("\t\tif err := w.WriteString(\"true\"); err != nil { return err }\n")
			code.WriteString("\t} else {\n")
			code.WriteString("\t\tif err := w.WriteString(\"false\"); err != nil { return err }\n")
			code.WriteString("\t}\n")
		default:
			// Fallback to reflection-based encoding
			code.WriteString(fmt.Sprintf("\tif err := marshalValue(reflect.ValueOf(v.%s), w); err != nil { return err }\n", field.Name))
		}
	}

	code.WriteString("\treturn w.WriteByte('}')\n")
	code.WriteString("}\n")

	return code.String(), nil
}

// FastTypeRegistry maintains compile-time generated encoders
type FastTypeRegistry struct {
	encoders map[reflect.Type]func(reflect.Value, writer) error
}

var fastRegistry = &FastTypeRegistry{
	encoders: make(map[reflect.Type]func(reflect.Value, writer) error),
}

// RegisterFastEncoder registers a compile-time generated encoder
func RegisterFastEncoder(t reflect.Type, encoder func(reflect.Value, writer) error) {
	fastRegistry.encoders[t] = encoder
}

// GetFastEncoder retrieves a compile-time generated encoder if available
func GetFastEncoder(t reflect.Type) (func(reflect.Value, writer) error, bool) {
	encoder, exists := fastRegistry.encoders[t]
	return encoder, exists
}

// Code generation utilities for build-time encoder generation
type CodeGen struct {
	Package string
	Types   []reflect.Type
}

// GenerateEncoders creates a Go source file with optimized encoders
func (c *CodeGen) GenerateEncoders() (string, error) {
	var code strings.Builder

	// Package declaration and imports
	code.WriteString("// Code generated by gravel JSON encoder generator. DO NOT EDIT.\n\n")
	code.WriteString(fmt.Sprintf("package %s\n\n", c.Package))
	code.WriteString("import (\n")
	code.WriteString("\t\"reflect\"\n")
	code.WriteString("\t\"strconv\"\n")
	code.WriteString("\tgraveljson \"github.com/freekieb7/gravel/json\"\n")
	code.WriteString(")\n\n")

	// Generate init function to register encoders
	code.WriteString("func init() {\n")

	compiler := &CompileTimeEncoder{encoders: make(map[reflect.Type]string)}

	for _, t := range c.Types {
		if t.Kind() == reflect.Struct {
			encoderCode, err := compiler.GenerateEncoder(t)
			if err != nil {
				continue
			}

			code.WriteString(encoderCode)
			code.WriteString("\n")

			// Register the encoder
			funcName := fmt.Sprintf("encode%s", t.Name())
			code.WriteString(fmt.Sprintf("\tgraveljson.RegisterFastEncoder(reflect.TypeOf((*%s)(nil)).Elem(), func(v reflect.Value, w graveljson.Writer) error {\n", t.String()))
			code.WriteString(fmt.Sprintf("\t\treturn %s(v.Interface().(%s), w)\n", funcName, t.String()))
			code.WriteString("\t})\n")
		}
	}

	code.WriteString("}\n")

	return code.String(), nil
}
